import { FileData } from '../types';
import { getWavespeedApiKey as getWavespeedApiKeyFromConfig, hasWavespeedApiKey as hasWavespeedApiKeyFromConfig, saveApiKeyToLocalStorage, clearApiKeyFromLocalStorage } from './configService';

// Save Wavespeed API Key
export const saveWavespeedApiKey = (apiKey: string) => {
  saveApiKeyToLocalStorage('wavespeed', apiKey);
};

// Check if Wavespeed API Key exists
export const hasWavespeedApiKey = async (): Promise<boolean> => {
  return await hasWavespeedApiKeyFromConfig();
};

// Clear Wavespeed API Key
export const clearWavespeedApiKey = () => {
  clearApiKeyFromLocalStorage('wavespeed');
};

// Upload image to get URL (SeeDream requires image URLs)
const uploadImageToTemporaryStorage = async (fileData: FileData): Promise<string> => {
  // For now, return the base64 data URL
  // In production, you'd upload to a CDN or temporary storage
  return fileData.previewUrl;
};

/**
 * Generate try-on image using SeeDream V4.5
 */
export const generateSeeDreamTryOn = async (
  person: FileData,
  top: FileData | null,
  bottom: FileData | null,
  shoes: FileData | null,
  poseIndex: number = 0
): Promise<string> => {
  const apiKey = await getWavespeedApiKeyFromConfig();
  
  // Build the prompt for SeeDream
  let prompt = `Virtual try-on: Keep the person's exact face, body, and features unchanged. `;
  
  if (top) {
    prompt += `Replace the top clothing with the new top garment shown. `;
  }
  if (bottom) {
    prompt += `Replace the bottom clothing with the new bottom garment shown. `;
  }
  if (shoes) {
    prompt += `Replace the footwear with the new shoes shown. `;
  }
  
  prompt += `Maintain the person's identity, proportions, and physical features. `;
  prompt += `Full body shot on pure white background. Professional catalog photography. `;
  
  // Add pose instructions
  const poses = [
    "Standing straight facing camera",
    "Body turned 45 degrees, face towards camera",
    "Side profile view",
    "Dynamic walking pose"
  ];
  prompt += poses[poseIndex % poses.length];
  
  // Convert image to base64 data URL (Wavespeed needs accessible URLs or base64)
  const imageBase64 = `data:${person.mimeType};base64,${person.base64}`;
  
  try {
    const response = await fetch('https://api.wavespeed.ai/api/v3/bytedance/seedream-v4.5/edit', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        enable_base64_output: false,
        enable_sync_mode: false, // Use async mode
        images: [imageBase64],  // Send as base64 data URL instead of blob URL
        prompt: prompt
      })
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`SeeDream API error: ${response.status} - ${errorText}`);
    }
    
    const data = await response.json();
    
    console.log('SeeDream API Response:', data); // Debug log
    
    // New Wavespeed API structure (data.id, data.urls.get)
    if (data.data && data.data.id && data.data.urls && data.data.urls.get) {
      console.log('Using new Wavespeed API structure with polling URL:', data.data.urls.get);
      return await pollWavespeedPrediction(apiKey, data.data.urls.get);
    }
    
    // Check if we got base64 output
    if (data.base64_output) {
      return `data:image/png;base64,${data.base64_output}`;
    }
    
    // Check for output_url (async mode)
    if (data.output_url) {
      const imgResponse = await fetch(data.output_url);
      const blob = await imgResponse.blob();
      return URL.createObjectURL(blob);
    }
    
    // Check if response has a different structure
    if (data.result && data.result.output_url) {
      const imgResponse = await fetch(data.result.output_url);
      const blob = await imgResponse.blob();
      return URL.createObjectURL(blob);
    }
    
    // Check for job_id (async mode - need to poll)
    if (data.job_id) {
      return await pollWavespeedJob(apiKey, data.job_id);
    }
    
    console.error('Unexpected SeeDream response structure:', data);
    throw new Error(`No image generated by SeeDream. Response: ${JSON.stringify(data).substring(0, 200)}`);
  } catch (error: any) {
    console.error('SeeDream generation error:', error);
    throw new Error(`Failed to generate with SeeDream: ${error.message}`);
  }
};

/**
 * Generate 4 photos with SeeDream
 */
export const generateMultipleSeeDreamImages = async (
  person: FileData,
  top: FileData | null,
  bottom: FileData | null,
  shoes: FileData | null
): Promise<string[]> => {
  const images: string[] = [];
  
  for (let i = 0; i < 4; i++) {
    const image = await generateSeeDreamTryOn(person, top, bottom, shoes, i);
    images.push(image);
  }
  
  return images;
};

/**
 * Generate try-on image using Flux 2 Pro
 */
export const generateFluxTryOn = async (
  person: FileData,
  top: FileData | null,
  bottom: FileData | null,
  shoes: FileData | null,
  poseIndex: number = 0
): Promise<string> => {
  const apiKey = await getWavespeedApiKeyFromConfig();
  
  // Build the prompt for Flux 2 Pro
  let prompt = `Transform this person into a high-end fashion editorial portrait. `;
  prompt += `CRITICAL: Keep the person's facial features, body proportions, skin tone, and natural expression COMPLETELY UNCHANGED. `;
  
  if (top) {
    prompt += `Replace the top clothing with a new ${top.file.name} garment. `;
  }
  if (bottom) {
    prompt += `Replace the bottom clothing with new ${bottom.file.name} pants/skirt. `;
  }
  if (shoes) {
    prompt += `Replace the footwear with new ${shoes.file.name} shoes. `;
  }
  
  prompt += `Apply professional studio lighting with refined directional highlights and soft shadows. `;
  prompt += `Create a Vogue-level editorial portrait on pure white background. `;
  prompt += `Full body shot showing complete person from head to feet. `;
  
  // Add pose instructions
  const poses = [
    "Standing straight facing camera, confident pose.",
    "Body turned 45 degrees, face towards camera, elegant stance.",
    "Side profile view, sophisticated posture.",
    "Dynamic walking pose, natural movement."
  ];
  prompt += poses[poseIndex % poses.length];
  
  prompt += ` Overall style: Premium natural beauty, sophisticated light shaping, high-fashion atmosphere, professional catalog photography.`;
  
  // Convert image to base64 data URL (Wavespeed needs accessible URLs or base64)
  const imageBase64 = `data:${person.mimeType};base64,${person.base64}`;
  
  try {
    const response = await fetch('https://api.wavespeed.ai/api/v3/wavespeed-ai/flux-2-pro/edit', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        enable_base64_output: false,
        enable_sync_mode: false, // Use async mode for Flux
        images: [imageBase64],  // Send as base64 data URL instead of blob URL
        prompt: prompt,
        seed: -1
      })
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Flux API error: ${response.status} - ${errorText}`);
    }
    
    const data = await response.json();
    
    console.log('Flux API Response:', data); // Debug log
    
    // New Wavespeed API structure (data.id, data.urls.get)
    if (data.data && data.data.id && data.data.urls && data.data.urls.get) {
      console.log('Using new Wavespeed API structure with polling URL:', data.data.urls.get);
      return await pollWavespeedPrediction(apiKey, data.data.urls.get);
    }
    
    // Check if we got base64 output
    if (data.base64_output) {
      return `data:image/png;base64,${data.base64_output}`;
    }
    
    // Check for output_url (async mode)
    if (data.output_url) {
      const imgResponse = await fetch(data.output_url);
      const blob = await imgResponse.blob();
      return URL.createObjectURL(blob);
    }
    
    // Check if response has a different structure
    if (data.result && data.result.output_url) {
      const imgResponse = await fetch(data.result.output_url);
      const blob = await imgResponse.blob();
      return URL.createObjectURL(blob);
    }
    
    // Check for job_id (async mode - need to poll)
    if (data.job_id) {
      // Flux is in async mode, need to poll for result
      return await pollWavespeedJob(apiKey, data.job_id);
    }
    
    console.error('Unexpected Flux response structure:', data);
    throw new Error(`No image generated by Flux. Response: ${JSON.stringify(data).substring(0, 200)}`);
  } catch (error: any) {
    console.error('Flux generation error:', error);
    throw new Error(`Failed to generate with Flux: ${error.message}`);
  }
};

/**
 * Poll Wavespeed prediction result using the GET URL from the API
 */
const pollWavespeedPrediction = async (apiKey: string, getUrl: string): Promise<string> => {
  const maxAttempts = 60; // 5 minutes max (5 seconds * 60)
  
  for (let i = 0; i < maxAttempts; i++) {
    await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds
    
    try {
      const response = await fetch(getUrl, {
        headers: {
          'Authorization': `Bearer ${apiKey}`
        }
      });
      
      if (!response.ok) {
        throw new Error(`Failed to check prediction status: ${response.status}`);
      }
      
      const result = await response.json();
      console.log(`Wavespeed prediction status (attempt ${i + 1}):`, result);
      
      // New API structure: data.outputs contains the result images
      if (result.data && result.data.outputs && result.data.outputs.length > 0) {
        const imageUrl = result.data.outputs[0];
        console.log('Image ready, downloading from:', imageUrl);
        
        const imgResponse = await fetch(imageUrl);
        const blob = await imgResponse.blob();
        return URL.createObjectURL(blob);
      }
      
      // Check if there's an error
      if (result.data && result.data.status === 'failed') {
        throw new Error(`Wavespeed prediction failed: ${result.data.error || 'Unknown error'}`);
      }
      
      // Continue polling if outputs is still empty (processing)
    } catch (error: any) {
      console.error('Error polling Wavespeed prediction:', error);
      throw error;
    }
  }
  
  throw new Error('Wavespeed generation timed out after 5 minutes');
};

/**
 * Poll Wavespeed job result (for async mode) - Works for both Flux and SeeDream (old API)
 */
const pollWavespeedJob = async (apiKey: string, jobId: string): Promise<string> => {
  const maxAttempts = 60; // 5 minutes max (5 seconds * 60)
  
  for (let i = 0; i < maxAttempts; i++) {
    await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds
    
    try {
      const response = await fetch(`https://api.wavespeed.ai/api/v3/jobs/${jobId}`, {
        headers: {
          'Authorization': `Bearer ${apiKey}`
        }
      });
      
      if (!response.ok) {
        throw new Error(`Failed to check job status: ${response.status}`);
      }
      
      const data = await response.json();
      console.log('Wavespeed job status:', data);
      
      if (data.status === 'completed' && data.output_url) {
        const imgResponse = await fetch(data.output_url);
        const blob = await imgResponse.blob();
        return URL.createObjectURL(blob);
      }
      
      if (data.status === 'failed') {
        throw new Error(`Wavespeed job failed: ${data.error || 'Unknown error'}`);
      }
      
      // Continue polling if status is 'processing' or 'queued'
    } catch (error: any) {
      console.error('Error polling Wavespeed job:', error);
      throw error;
    }
  }
  
  throw new Error('Wavespeed generation timed out');
};

/**
 * Generate 4 photos with Flux 2 Pro
 */
export const generateMultipleFluxImages = async (
  person: FileData,
  top: FileData | null,
  bottom: FileData | null,
  shoes: FileData | null
): Promise<string[]> => {
  const images: string[] = [];
  
  for (let i = 0; i < 4; i++) {
    const image = await generateFluxTryOn(person, top, bottom, shoes, i);
    images.push(image);
  }
  
  return images;
};






